#include <stdio.h>
#include <stdlib.h>

// 如何定义一个int类型的指针数组,数组元素为10个
// int* a[10]    
// int(*a[10])(int)  函数指针数组 参数为int 返回值也为int的函数指针数组
// 

// 函数指针操作中 & 和*都是意义不大的行为
// 函数指针本身就不是一个真正的指针
// 
// 函数不调用就没有实际的执行空间
// 而后面的代码中test连空间都没有 赋值没有意义
// 实际赋的是一个假地址(映射地址) 可以理解为函数的入口地址
// 在函数分配时有一个符号表 给这个函数分配了一个假地址 
// 只要这个地址出现了 就相当于函数出现了, test相当于一个标志 => 代码的地址
// 不是一个真正的指针 只是一个标签 代表函数的内容 
// 如果添加多余的解引用标记 会被直接忽略 
// 如果是普通的函数指针 我们不需要解引用标记
// 但是解引用标记对二级指针 函数指针数组是有用
void test(){
	printf("test\n");
}
int main1(){
	//void(*pf)() = test;
	void(*pf)() = &test;// 加了&效果一样 没有影响

	//pf();
	//(*pf)(); // 加了* 效果也一样 没影响
	//(**pf)();// 同样可以 加多少个都没影响
	(&*****&*******&********&********pf)();// 都没有影响 取地址符&不能连续出现

	system("pause");
	return 0;
}
int  main(){

    // void(**pf) = &test;// 程序崩啦
	// 由于函数名前面执行的& 会被忽略,所以加& 也没有用
	// 所以赋的值还是一个一级指针
	// 把一个一级指针赋给一个二级指针 然后解引用 再用小括号()解第二次引用时 出错了
	// ()也相当于解引用 
	// 所以我们必须要有一个一级函数指针 然后再对一级函数指针取地址 才能到二级函数指针
	
	void(*pf)() = &test;
	void(**ppf)() = &pf;

	//pf();// 若为 void(**pf)就不行了 必须有*了
	(*ppf)();// 这是一个二级函数指针 解引用一次得到结果(小括号也算解引用)
	(**ppf)();// 如果解引用两次 还是可以得到结果 因为多余的忽略掉了
	// 但是只有一个解引用* 是用到了 哪怕写一串依然是对的 只有一个*指针有用
	// 如果是一级函数指针 那就全部忽略掉了 
	// 多级函数指针只有对应的几级*保留它的功能
	(*&*ppf)();// 成立
	(&**ppf)();// 依旧成立 编译的时候会把成对的&*去掉
	// 只要看到&前面或者后面出现解引用 直接去掉&和*
	//(&*&*ppf)();  
	// 错了 级数不对了 直接通过()调了一个二级指针
	// 表达式前的括号必须具有(指针)函数类型 再补个*就好了
	// 可是如果& >= 解引用*了 就错了
	// *必须比&多一个 取地址不能连续出现
	// (&*&*&pf)(); 此时pf为一个二级指针 因为多了一个& &对pf取地址了 为一个二级函数指针

	system("pause");
	return 0;
}





















